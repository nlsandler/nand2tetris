#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import parse
from typing import IO

CMPS = {
    "not":"!",
    "neg":"-",
    "and":"&",
    "or":"|",
    "add":"+",
    "sub":"-",
    "gt":"JGT",
    "lt":"JLT",
    "eq":"JEQ"
}

BASE_PTRS = {
    "local": "LCL",
    "this": "THIS",
    "that": "THAT",
    "argument": "ARG"
}

BASE_VALS = {
    "pointer": "3",
    "temp": "5"
}

#instructions to push D onto stack and increment SP
PUSH_D_INSTRUCTIONS = """
    @SP
    A=M
    M=D
    @SP
    M=M+1
"""

#instructions to load value at segment[index] into D
#for directly memory-mapped segments (pointer, temp), {reg} is A
#for segments where we only store base ptr (local, argument, this, that),
#we need to dereference that pointer, so {reg} is M 
LOAD_INTO_D_INSTRUCTIONS = """
//push {segment} {index}
    @{base}
    D={reg} //D holds base address of segment
    @{index}
    A=D+A //A holds address of value we want to push
    D=M //D holds value we want to push"""

POP_INTO_D_INSTRUCTIONS ="""
//pop top of stack into D
    @SP
    AM=M-1
    D=M //D holds top value on stack
"""

#instructions to pop value into segment[index]
#for directly memory-mapped segments (pointer, temp), {reg} is A
#for segments where we only store base ptr (local, argument, this, that),
#we need to dereference that pointer, so {reg} is M 
POP_INSTRUCTIONS = """
//pop {segment} {index}

//calculate value we want to pop to, store in R13
    @{base}
    D={reg} //D holds base address of segment
    @{index}
    D=D+A //D holds address we want to write to
    @R13
    M=D //store address to write to in R13
"""+POP_INTO_D_INSTRUCTIONS+"""
//write D to address stored in R13
    @R13
    A=M
    M=D"""

#instructions to pop top of stack into D and decrement SP

class Writer:

    def __init__(self, f: IO[str]) -> None:
        self.f = f
        self.label_ctr = 0 # for autogenerated labels
        self.in_filename = None
        self.current_fun: str = None

    def label(self):
        if self.current_fun:
            label = "{f}${i}".format(f=self.current_fun, i=self.label_ctr)
        else:
            label = "label{i}".format(i=self.label_ctr)
        self.label_ctr += 1
        return label

    def write_arithmetic(self, command: parse.Command) -> None:
        op = command.arg1
        comp = CMPS[op]
        if op in parse.UNARY_OPS:
            instructions = """//{op}
    @SP
    A=M-1
    M={cmp}M""".format(op=op, cmp=comp)
        elif op in parse.BINARY_OPS:
            instructions = """//{op}
    @SP
    AM=M-1
    D=M
    @SP
    A=M-1
    M=M{cmp}D""".format(op=op, cmp=comp)
        elif op in parse.CMP_OPS:
            instructions = """//{op}
//set result to -1 (true)
    @R13
    M=-1
//pop both values off the stack
    @SP
    AM=M-1
    D=M
    @SP
    A=M-1
//perform comparison
    D=M-D
    @{label}
    D;{cmp}
//comparison was false, set result to 0
    @R13
    M=0
({label})
//add result to stack
    @R13
    D=M
    @SP
    A=M-1
    M=D""".format(op=op, cmp=comp, label=self.label())
            self.label_ctr += 1
        else:
            raise RuntimeError("Unknown op")

        #write the instruction
        self.f.write(instructions+"\n")


    def write_push(self, command: parse.Command) -> None:
        segment = command.arg1
        index = command.arg2
        #first generate code to get value into D

        if segment == "constant":
            instructions = """//push constant {c}
    @{c}
    D=A""".format(c=index)
        elif segment in BASE_PTRS:
            base = BASE_PTRS[segment]
            instructions = LOAD_INTO_D_INSTRUCTIONS.format(index=index, 
                                                                segment=segment, 
                                                                base=base, reg="M")
        elif segment in BASE_VALS:
            base = BASE_VALS[segment]
            instructions = LOAD_INTO_D_INSTRUCTIONS.format(index=index, 
                                                                segment=segment, 
                                                                base=base, reg="A")
        elif segment == "static":
            #make sure in_filename is set
            if not self.in_filename:
                raise RuntimeError("No input filename set!")

            instructions = """//push static {index}
    @{filename}.{index}
    D=M""".format(index=index, filename=self.in_filename)

        else:
            raise RuntimeError("{} is not a real segment".format(segment))

        #Now push value in D onto stack
        instructions += PUSH_D_INSTRUCTIONS

        self.f.write(instructions+"\n")

    def write_pop(self, command: parse.Command) -> None:
        segment = command.arg1
        index = command.arg2
        if segment in BASE_PTRS:
            base = BASE_PTRS[segment]
            instructions = POP_INSTRUCTIONS.format(index=index,
                                                        segment=segment,
                                                        base=base, reg="M")

        elif segment in BASE_VALS:
            base = BASE_VALS[segment]
            instructions = POP_INSTRUCTIONS.format(index=index,
                                                        segment=segment,
                                                        base=base, reg="A") 

        elif segment == "static":
            instructions = """//pop static {index}
    @{filename}.{index}
    D=A
    @R13
    M=D //store address to write to in R13

//pop top of stack into D
    @SP
    AM=M-1
    D=M //D holds top value on stack

//write D to address stored in R13
    @R13
    A=M
    M=D""".format(index=index, filename=self.in_filename)

        elif segment == "constant":
            raise RuntimeError("Cannot pop a constant")          

        else:
            raise NotImplementedError("segment {}".format(segment))

        self.f.write(instructions+"\n")           

    def write_push_pop(self, command:  parse.Command) -> None:
        if command.cmd_type == parse.CmdType.PUSH:
            self.write_push(command)

        elif command.cmd_type == parse.CmdType.POP:
            self.write_pop(command)

        else:
            raise RuntimeError("Expected command type push or pop, got {}".format(command.cmd_type))

    def write_label(self, command: parse.Command, current_fun: str=None) -> None:
        label = command.arg1
        if current_fun:
            label = "{f}$label".format(f=current_fun, label=label)
        instruction = "({label})".format(label=label)
        self.f.write(instruction+"\n")

    def write_goto(self, command: parse.Command, current_fun: str=None) -> None:
        if current_fun:
            label = "{f}$label".format(f=current_fun, label=label)
        label = command.arg1
        instructions = """//goto {label}
    @{label}
    0;JMP""".format(label=label)
        self.f.write(instructions+"\n")

    def write_if(self, command: parse.Command, current_fun: str=None) -> None:
        label = command.arg1
        if current_fun:
            label = "{f}$label".format(f=current_fun, label=label)
        instructions = POP_INTO_D_INSTRUCTIONS + """
//if-goto {label}
    @{label}
    D;JNE""".format(label=label)
        self.f.write(instructions+"\n")

    def _push_symbol(self, symbol):
        return """//push {symbol}
    @{symbol}
    D=M""".format(symbol=symbol) + PUSH_D_INSTRUCTIONS

    def write_call(self, command: parse.Command) -> None:
        fun = command.arg1
        n_args = int(command.arg2)
        ret_label = self.label() # autogenerate based on name of current function

        instructions = "//call {fun} {n_args}".format(fun=fun, n_args=n_args)

        #push ret_label onto stack
        instructions += """
    @{ret_label}
    D=A""".format(ret_label=ret_label) + PUSH_D_INSTRUCTIONS

        # push segment pointers onto stack
        vals_to_push = ["LCL", "ARG", "THIS", "THAT"]
        for val in vals_to_push:
            instructions += self._push_symbol(val)

        # point ARG to the args we pushed on the stack, i.e.
        # ARG = SP-nArgs - 5
        # comment in slides says this commnand "repositions SP for g" but I think that's incorrect
        instructions += """//ARG = SP - {n_args} - 5
    @{n_args}
    D=A
    @SP
    D=M-D //D = SP - nArgs
    @5
    D=D-A //D = SP - nArgs - 5
    @ARG
    M=D //save D in ARG register
""".format(n_args=n_args)        

        # point LCL to top of stack (where local variables will be)
        instructions += """//LCL = SP
    @SP
    D=M
    @LCL
    M=D
"""
    
        # emit goto instruction
        instructions += """//goto {fun}
    @{fun}
    0;JMP
""".format(fun=fun)

        # emit return address label
        instructions += "({ret_label})\n".format(ret_label=ret_label)
        self.f.write(instructions)

    def write_function(self, command: parse.Command) -> None:
        fun = command.arg1
        n_args = int(command.arg2)
        instructions = """//function {f} {n_args}
({f})
""".format(f=fun, n_args=n_args)
        push_zero_instructions = "    D=0\n" + PUSH_D_INSTRUCTIONS
        instructions += push_zero_instructions * n_args
        self.f.write(instructions)

        self.current_fun = fun
        self.label_ctr = 0

    def write_return(self, command: parse.Command) -> None:
        instructions = """//return
//get base address of LCL (i.e. base of stack frame)
    @LCL
    D=M // D contains base address of LCL (i.e. base of stack frame)
    @R13
    M=D //store frame in R13

//store ret address (stack frame - 5) in R14
    @5
    D=A
    @R13
    A=M-D
    D=M //D is *(frame - 5)
    @R14
    M=D
""" + POP_INTO_D_INSTRUCTIONS + """
//move value from D into arg[0]
    @ARG
    A=M // dereference ARG pointer
    M=D // stack location that held arg 0 now holds D

//then restore stack pointer to the right place
    @ARG
    D=M
    @SP
    M=D+1

//restore memory segments from caller
    @1
    D=A
    @R13
    A=M-D
    D=M //D is *(frame - 1)
    @THAT
    M=D //THAT = *(frame-1)

    @2
    D=A
    @R13
    A=M-D
    D=M //D is *(frame - 2)
    @THIS
    M=D

    @3
    D=A
    @R13
    A=M-D
    D=M //D is *(frame - 3)
    @ARG
    M=D

    @4
    D=A
    @R13
    A=M-D
    D=M //D is *(frame - 4)
    @LCL
    M=D

//go to return address
    @R14
    A=M
    0;JMP
"""
        self.f.write(instructions)



